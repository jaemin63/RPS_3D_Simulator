import React, { useEffect, useRef, useState } from "react";
import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader.js";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import Stats from "three/examples/jsm/libs/stats.module.js";

// Hooks
import { useAGVControl } from "../hooks/useAGVControl";
import { useLiftControl } from "../hooks/useLiftControl";
import { useSecondControl } from "../hooks/useSecondControl";
import { useSimulation } from "../hooks/useSimulation";
import { useAnimationUpdater } from "../hooks/useAnimationUpdater";

// Utils
import { disposeObject, fitCameraToBox, createPivotMarker } from "../utils/threeUtils";
import { createAGVGroup } from "../utils/agvGroupUtils";

// Components
import {
  SimulationControl,
  AGVJogControl,
  LiftJogControl,
  SecondJogControl,
} from "./controls";

type Props = { src: string; background?: number; helpers?: boolean };

const GLTFViewer: React.FC<Props> = ({ src, background = 0x111214, helpers = true }) => {
  // Three.js refs
  const mountRef = useRef<HTMLDivElement | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const modelRef = useRef<THREE.Object3D | null>(null);
  const bboxHelperRef = useRef<THREE.Box3Helper | null>(null);
  const statsRef = useRef<any>(null);

  // Model state
  const [status, setStatus] = useState("");
  const [ready, setReady] = useState(false);
  const [showPanel, setShowPanel] = useState(true);

  // Cover & Object state
  const [coverList, setCoverList] = useState<string[]>([]);
  const [coverTransparency, setCoverTransparency] = useState<Map<string, number>>(new Map());
  const [hiddenObjects, setHiddenObjects] = useState<Set<string>>(new Set());
  const [objectCategories, setObjectCategories] = useState<Map<string, string[]>>(new Map());
  const [coverInstances, setCoverInstances] = useState<Map<string, string[]>>(new Map());
  const [expandedCovers, setExpandedCovers] = useState<Set<string>>(new Set());
  const [showCoverList, setShowCoverList] = useState(false);
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set());

  // Animation ref (temporary, will be replaced by useAnimationUpdater)
  const tempAnimationRef = useRef({});

  // Custom hooks
  const agvControl = useAGVControl(tempAnimationRef);
  const liftControl = useLiftControl(tempAnimationRef);
  const secondControl = useSecondControl(tempAnimationRef);

  // Animation updater (replaces tempAnimationRef with real one)
  const { animationRef, updateAnimations } = useAnimationUpdater(
    {
      agvGroupRef: agvControl.agvGroupRef,
      liftGroupRef: liftControl.liftGroupRef,
      secondGroupRef: secondControl.secondGroupRef,
      currentAgvZRef: agvControl.currentAgvZRef,
      currentAgvRotationRef: agvControl.currentAgvRotationRef,
      currentLiftYRef: liftControl.currentLiftYRef,
      currentSecondZRef: secondControl.currentSecondZRef,
    },
    {
      setAgvZPosition: agvControl.setAgvZPosition,
      setAgvRotation: agvControl.setAgvRotation,
      setLiftYPosition: liftControl.setLiftYPosition,
      setSecondLocalZ: secondControl.setSecondLocalZ,
    }
  );

  // Replace temp ref with real animation ref
  React.useEffect(() => {
    tempAnimationRef.current = animationRef.current;
  }, [animationRef]);

  // Simulation
  const simulation = useSimulation({
    setAgvZPositionDirect: agvControl.setAgvZPositionDirect,
    setAgvRotationDirect: agvControl.setAgvRotationDirect,
    setLiftYPositionDirect: liftControl.setLiftYPositionDirect,
    setSecondLocalZDirect: secondControl.setSecondLocalZDirect,
  });

  // Update pivot marker helper
  const updatePivotMarker = (position: { x: number; y: number; z: number }) => {
    if (!sceneRef.current) return;

    if (agvControl.agvPivotMarkerRef.current) {
      sceneRef.current.remove(agvControl.agvPivotMarkerRef.current);
      agvControl.agvPivotMarkerRef.current.geometry.dispose();
      (agvControl.agvPivotMarkerRef.current.material as THREE.Material).dispose();
      agvControl.agvPivotMarkerRef.current = null;
    }

    const marker = createPivotMarker(position);
    sceneRef.current.add(marker);
    agvControl.agvPivotMarkerRef.current = marker;
  };

  // ========== Three.js 초기화 ==========
  useEffect(() => {
    const mount = mountRef.current;
    if (!mount) return;

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      powerPreference: "high-performance",
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.sortObjects = true;

    const updateSize = () => {
      const w = mount.clientWidth || 1;
      const h = mount.clientHeight || 1;
      renderer.setSize(w, h, false);
      if (cameraRef.current) {
        cameraRef.current.aspect = w / h;
        cameraRef.current.updateProjectionMatrix();
      }
    };
    updateSize();

    const canvas = renderer.domElement;
    canvas.style.display = "block";
    canvas.style.pointerEvents = "auto";
    canvas.style.touchAction = "none";
    mount.appendChild(canvas);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(background);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 10000);
    camera.position.set(5, 5, 5);

    scene.add(new THREE.AmbientLight(0xffffff, 2.0));
    const dirLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight1.position.set(5, 10, 5);
    scene.add(dirLight1);
    const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight2.position.set(-5, 5, -5);
    scene.add(dirLight2);
    const dirLight3 = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight3.position.set(0, -5, 0);
    scene.add(dirLight3);

    if (helpers) {
      scene.add(new THREE.GridHelper(20, 20, 0x888888, 0x444444));
      scene.add(new THREE.AxesHelper(2));
    }

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.screenSpacePanning = true;

    rendererRef.current = renderer;
    sceneRef.current = scene;
    cameraRef.current = camera;
    controlsRef.current = controls;

    const stats = new Stats();
    stats.dom.style.position = "absolute";
    stats.dom.style.left = "12px";
    stats.dom.style.top = "12px";
    stats.dom.style.zIndex = "1000";
    mount.appendChild(stats.dom);
    statsRef.current = stats;

    const ro = new ResizeObserver(updateSize);
    ro.observe(mount);

    let raf = 0;
    const loop = () => {
      raf = requestAnimationFrame(loop);
      updateAnimations();
      controls.update();
      renderer.render(scene, camera);
      stats.update();
    };
    loop();

    console.log("[GLTFViewer] Three.js initialized");
    setReady(true);

    return () => {
      console.log("[GLTFViewer] Cleanup");
      setReady(false);
      cancelAnimationFrame(raf);
      ro.disconnect();
      controls.dispose();
      if (bboxHelperRef.current) scene.remove(bboxHelperRef.current);
      disposeObject(modelRef.current);
      renderer.dispose();
      if (statsRef.current) mount.removeChild(stats.dom);
      mount.removeChild(canvas);
    };
  }, [background, helpers, updateAnimations]);

  // ========== GLTF 모델 로드 ==========
  useEffect(() => {
    if (!ready || !src || !sceneRef.current || !cameraRef.current) return;

    let aborted = false;

    (async () => {
      try {
        console.log("[GLTFViewer] Loading model:", src);
        setStatus("Loading…");

        const scene = sceneRef.current!;
        const camera = cameraRef.current!;
        const controls = controlsRef.current!;

        if (bboxHelperRef.current) {
          scene.remove(bboxHelperRef.current);
          bboxHelperRef.current = null;
        }
        if (modelRef.current) {
          scene.remove(modelRef.current);
          disposeObject(modelRef.current);
          modelRef.current = null;
        }

        const loader = new GLTFLoader();
        const draco = new DRACOLoader();
        draco.setDecoderPath("/draco/");
        loader.setDRACOLoader(draco);

        try {
          const mod: any = await import("three/examples/jsm/libs/meshopt_decoder.module.js");
          loader.setMeshoptDecoder(mod.default ?? mod);
        } catch {}

        const res = await fetch(src, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} on ${src}`);
        const buf = await res.arrayBuffer();
        const base = src.substring(0, src.lastIndexOf("/") + 1);

        const gltf = await new Promise<any>((ok, err) => loader.parse(buf, base, (g) => ok(g), err));
        if (aborted) return;

        const root: THREE.Object3D = gltf.scene;
        console.log("[GLTFViewer] GLTF parsed, processing meshes...");

        let meshCount = 0;
        const covers = new Set<string>();
        const categories = new Map<string, string[]>();
        const instances = new Map<string, string[]>();

        root.traverse((node: any) => {
          if (node.isMesh) {
            meshCount++;
            node.frustumCulled = false;

            if (node.name) {
              const baseName = node.name.replace(/_\d+$/, "");
              const fullName = node.name;

              if (baseName.startsWith("RPS_COVER")) {
                covers.add(baseName);
                if (!instances.has(baseName)) {
                  instances.set(baseName, []);
                }
                instances.get(baseName)!.push(fullName);
              }

              const prefix = baseName.split(/[_\d]/)[0];
              if (prefix && prefix.length > 0) {
                if (!categories.has(prefix)) {
                  categories.set(prefix, []);
                }
                const list = categories.get(prefix)!;
                if (!list.includes(baseName)) {
                  list.push(baseName);
                }
              }
            }

            if (!node.material) {
              node.material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            }

            const materials = Array.isArray(node.material) ? node.material : [node.material];
            materials.forEach((mat: any) => {
              if (mat.isMaterial) {
                mat.side = THREE.DoubleSide;
                mat.transparent = false;
                mat.opacity = 1.0;
                mat.depthTest = true;
                mat.depthWrite = true;
                mat.precision = "mediump";
                mat.alphaTest = 0.01;
                mat.needsUpdate = true;
              }
            });
          }
        });
        console.log("[GLTFViewer] Processed", meshCount, "meshes");

        const coverArray = Array.from(covers).sort();
        setCoverList(coverArray);
        setObjectCategories(categories);
        setCoverInstances(instances);
        setCoverTransparency(new Map());

        const box = new THREE.Box3().setFromObject(root);
        if (box.isEmpty()) {
          throw new Error("Model has no geometry (empty bounding box)");
        }

        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        const maxSide = Math.max(size.x, size.y, size.z);
        if (maxSide > 0) {
          const scale = 5 / maxSide;
          root.scale.setScalar(scale);

          const scaledMin = box.min.clone().multiplyScalar(scale);
          const scaledCenter = center.clone().multiplyScalar(scale);

          root.position.set(-scaledCenter.x, -scaledMin.y, -scaledCenter.z);
        }

        scene.add(root);
        modelRef.current = root;

        const newBox = new THREE.Box3().setFromObject(root);
        const helper = new THREE.Box3Helper(newBox, 0xff00ff);
        scene.add(helper);
        bboxHelperRef.current = helper;

        const targetCenter = new THREE.Vector3();
        newBox.getCenter(targetCenter);
        fitCameraToBox(camera, newBox, 1.3);
        controls.target.copy(targetCenter);
        controls.update();

        // AGV 그룹 자동 생성
        const result = createAGVGroup({
          scene,
          agvPivot: agvControl.agvPivot,
          updatePivotMarkerCallback: updatePivotMarker,
        });

        agvControl.agvGroupRef.current = result.agvGroup;
        liftControl.liftGroupRef.current = result.liftGroup;
        secondControl.secondGroupRef.current = result.secondGroup;

        if (result.liftGroup) {
          liftControl.setLiftYPosition(0);
        }
        if (result.secondGroup) {
          secondControl.setSecondLocalZ(0);
        }

        setStatus("");
      } catch (e: any) {
        if (aborted) return;
        console.error("[GLTFViewer] Load error:", e);
        setStatus(`Error: ${e?.message || e}`);
      }
    })();

    return () => {
      aborted = true;
    };
  }, [src, ready, agvControl, liftControl, secondControl]);

  // ========== COVER 투명도 적용 ==========
  useEffect(() => {
    if (!modelRef.current) return;

    modelRef.current.traverse((node: any) => {
      if (node.isMesh && node.name && node.name.startsWith("RPS_COVER")) {
        const fullName = node.name;
        const baseName = fullName.replace(/_\d+$/, "");

        const level = coverTransparency.get(fullName) || coverTransparency.get(baseName) || 0;

        const opacityMap = [1.0, 0.6, 0.3];
        const opacity = opacityMap[level];
        const isTransparent = level > 0;

        const materials = Array.isArray(node.material) ? node.material : [node.material];
        materials.forEach((mat: any) => {
          if (mat.isMaterial) {
            mat.transparent = isTransparent;
            mat.opacity = opacity;
            mat.depthWrite = !isTransparent;

            if (isTransparent) {
              mat.alphaTest = 0.05;
              node.renderOrder = level;
            } else {
              mat.alphaTest = 0.01;
              node.renderOrder = 0;
            }

            mat.needsUpdate = true;
          }
        });
      }
    });
  }, [coverTransparency]);

  // ========== 객체 숨기기/보이기 ==========
  useEffect(() => {
    if (!sceneRef.current) return;

    sceneRef.current.traverse((node: any) => {
      if (node.isMesh && node.name) {
        const fullName = node.name;
        const baseName = fullName.replace(/_\d+$/, "");

        const shouldHide = hiddenObjects.has(fullName) || hiddenObjects.has(baseName);
        node.visible = !shouldHide;
      }
    });
  }, [hiddenObjects]);

  // ========== COVER & Object 제어 함수 ==========
  const toggleCoverTransparency = (coverName: string) => {
    setCoverTransparency((prev) => {
      const next = new Map(prev);
      const currentLevel = next.get(coverName) || 0;
      const nextLevel = (currentLevel + 1) % 3;

      if (nextLevel === 0) {
        next.delete(coverName);
      } else {
        next.set(coverName, nextLevel);
      }
      return next;
    });
  };

  const setAllTransparent = () => {
    const allTransparent = new Map<string, number>();
    coverList.forEach((name) => allTransparent.set(name, 2));
    setCoverTransparency(allTransparent);
  };

  const setAllOpaque = () => setCoverTransparency(new Map());

  const toggleCategoryVisibility = (category: string) => {
    const objects = objectCategories.get(category) || [];
    const allHidden = objects.every((obj) => hiddenObjects.has(obj));

    setHiddenObjects((prev) => {
      const next = new Set(prev);
      if (allHidden) {
        objects.forEach((obj) => next.delete(obj));
      } else {
        objects.forEach((obj) => next.add(obj));
      }
      return next;
    });
  };

  const toggleObjectVisibility = (objectName: string) => {
    setHiddenObjects((prev) => {
      const next = new Set(prev);
      if (next.has(objectName)) {
        next.delete(objectName);
      } else {
        next.add(objectName);
      }
      return next;
    });
  };

  // ========== UI 렌더링 ==========
  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        display: "flex",
        margin: 0,
        padding: 0,
      }}
    >
      {/* 3D 뷰어 */}
      <div
        style={{
          width: showPanel ? "80%" : "100%",
          height: "100%",
          position: "relative",
          overflow: "hidden",
          transition: "width 0.3s ease",
        }}
      >
        <div
          ref={mountRef}
          style={{
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            touchAction: "none",
          }}
        />
        {status && (
          <div
            style={{
              position: "absolute",
              left: 12,
              top: 12,
              padding: "8px 12px",
              background: "rgba(0,0,0,0.7)",
              color: "#fff",
              fontSize: 13,
              borderRadius: 6,
              pointerEvents: "none",
            }}
          >
            {status}
          </div>
        )}

        {/* 패널 토글 버튼 */}
        <button
          onClick={() => setShowPanel(!showPanel)}
          style={{
            position: "absolute",
            right: 12,
            top: 12,
            padding: "8px 16px",
            background: showPanel ? "#4a9eff" : "#666",
            color: "#fff",
            border: "none",
            borderRadius: 6,
            fontSize: 12,
            fontWeight: 600,
            cursor: "pointer",
            boxShadow: "0 2px 8px rgba(0,0,0,0.3)",
            transition: "background 0.2s",
            zIndex: 1000,
          }}
          onMouseEnter={(e) => (e.currentTarget.style.background = showPanel ? "#3a8eef" : "#555")}
          onMouseLeave={(e) => (e.currentTarget.style.background = showPanel ? "#4a9eff" : "#666")}
        >
          {showPanel ? "Hide Panel ▶" : "◀ Show Panel"}
        </button>
      </div>

      {/* 우측 패널 */}
      {showPanel && (
        <div
          style={{
            width: "20%",
            height: "100%",
            background: "#1e1e23",
            color: "#fff",
            overflowY: "auto",
            padding: "16px",
            borderLeft: "1px solid #444",
            boxSizing: "border-box",
          }}
        >
          <h3 style={{ margin: "0 0 12px 0", fontSize: 16, fontWeight: 600 }}>Control Panel</h3>
          <div style={{ fontSize: 12, color: "#ccc", marginBottom: 16 }}>RPS GLTF Viewer</div>

          {/* 시뮬레이션 컨트롤 */}
          <SimulationControl
            isSimulating={simulation.isSimulating}
            onStart={simulation.runSimulation}
            onStop={simulation.stopSimulation}
          />

          {/* AGV Jog 컨트롤 */}
          <AGVJogControl
            agvZPosition={agvControl.agvZPosition}
            agvRotation={agvControl.agvRotation}
            agvPivot={agvControl.agvPivot}
            onMoveZ={agvControl.moveAgvZ}
            onSetZ={agvControl.setAgvZPositionDirect}
            onRotate={agvControl.rotateAgv}
            onSetRotation={agvControl.setAgvRotationDirect}
            onUpdatePivot={agvControl.updateAgvPivot}
          />

          {/* LIFT Jog 컨트롤 */}
          {liftControl.liftGroupRef.current && (
            <LiftJogControl
              liftYPosition={liftControl.liftYPosition}
              onMove={liftControl.moveLiftY}
              onSetPosition={liftControl.setLiftYPositionDirect}
            />
          )}

          {/* SECOND Jog 컨트롤 */}
          {secondControl.secondGroupRef.current && (
            <SecondJogControl
              secondLocalZ={secondControl.secondLocalZ}
              onMove={secondControl.moveSecondLocal}
              onSetPosition={secondControl.setSecondLocalZDirect}
            />
          )}

          {/* Object Categories */}
          <div style={{ marginBottom: 20, paddingBottom: 16, borderBottom: "1px solid #333" }}>
            <div style={{ fontSize: 13, fontWeight: 600, marginBottom: 10, color: "#fff" }}>Object Categories</div>
            <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
              {Array.from(objectCategories.entries())
                .sort((a, b) => a[0].localeCompare(b[0]))
                .map(([category, objects]) => {
                  const hiddenCount = objects.filter((obj) => hiddenObjects.has(obj)).length;
                  const allHidden = hiddenCount === objects.length;
                  const someHidden = hiddenCount > 0 && hiddenCount < objects.length;
                  const isExpanded = expandedCategories.has(category);
                  const hasMultipleObjects = objects.length > 1;

                  return (
                    <div key={category} style={{ display: "flex", flexDirection: "column", gap: 2 }}>
                      <div style={{ display: "flex", alignItems: "center", gap: 4 }}>
                        {hasMultipleObjects && (
                          <div
                            onClick={(e) => {
                              e.stopPropagation();
                              setExpandedCategories((prev) => {
                                const next = new Set(prev);
                                if (next.has(category)) {
                                  next.delete(category);
                                } else {
                                  next.add(category);
                                }
                                return next;
                              });
                            }}
                            style={{
                              fontSize: 10,
                              cursor: "pointer",
                              color: "#888",
                              minWidth: 14,
                              textAlign: "center",
                            }}
                          >
                            {isExpanded ? "▼" : "▶"}
                          </div>
                        )}
                        <div
                          onClick={() => toggleCategoryVisibility(category)}
                          style={{
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "space-between",
                            fontSize: 11,
                            cursor: "pointer",
                            padding: "5px 8px",
                            background: allHidden ? "#1a1a22" : someHidden ? "#252530" : "transparent",
                            borderRadius: 3,
                            border: `1px solid ${allHidden ? "#555" : someHidden ? "#666" : "#333"}`,
                            opacity: allHidden ? 0.5 : 1,
                            flex: 1,
                          }}
                        >
                          <span style={{ color: allHidden ? "#888" : "#ccc" }}>{category}</span>
                          <span style={{ fontSize: 9, color: "#777" }}>
                            {allHidden ? "숨김" : someHidden ? `${hiddenCount}/${objects.length}` : objects.length}
                          </span>
                        </div>
                      </div>

                      {isExpanded && hasMultipleObjects && (
                        <div style={{ marginLeft: 20, display: "flex", flexDirection: "column", gap: 2 }}>
                          {objects.map((objectName) => {
                            const isHidden = hiddenObjects.has(objectName);
                            return (
                              <div
                                key={objectName}
                                onClick={() => toggleObjectVisibility(objectName)}
                                style={{
                                  display: "flex",
                                  alignItems: "center",
                                  justifyContent: "space-between",
                                  fontSize: 10,
                                  cursor: "pointer",
                                  padding: "4px 6px",
                                  background: isHidden ? "#1a1a25" : "transparent",
                                  borderRadius: 2,
                                  border: `1px solid ${isHidden ? "#555" : "#222"}`,
                                  opacity: isHidden ? 0.5 : 0.9,
                                }}
                              >
                                <span style={{ color: isHidden ? "#777" : "#aaa" }}>{objectName}</span>
                                <span style={{ fontSize: 8, color: "#666" }}>{isHidden ? "숨김" : "표시"}</span>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  );
                })}
            </div>
          </div>

          {/* COVER Parts */}
          <div style={{ marginBottom: 12 }}>
            <div
              onClick={() => setShowCoverList(!showCoverList)}
              style={{
                fontSize: 13,
                fontWeight: 600,
                marginBottom: 10,
                color: "#fff",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                gap: 8,
              }}
            >
              <span>{showCoverList ? "▼" : "▶"}</span>
              <span>COVER Parts ({coverList.length})</span>
            </div>

            <div style={{ marginBottom: 12, display: "flex", gap: 8 }}>
              <button
                onClick={setAllTransparent}
                style={{
                  flex: 1,
                  padding: "6px 12px",
                  fontSize: 10,
                  fontWeight: 600,
                  background: "#5c7cfa",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                }}
              >
                All Transparent
              </button>
              <button
                onClick={setAllOpaque}
                style={{
                  flex: 1,
                  padding: "6px 12px",
                  fontSize: 10,
                  fontWeight: 600,
                  background: "#666",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                }}
              >
                All Opaque
              </button>
            </div>

            {showCoverList && (
              <>
                <div style={{ fontSize: 10, color: "#777", marginBottom: 12, lineHeight: 1.4 }}>
                  클릭: 0(불투명) → 1(약한 반투명) → 2(강한 반투명) → 0
                </div>
                <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
                  {coverList.map((coverName) => {
                    const level = coverTransparency.get(coverName) || 0;
                    const labels = ["불투명", "약함", "강함"];
                    const colors = ["#666", "#88ccff", "#4a9eff"];
                    const instances = coverInstances.get(coverName) || [];
                    const hasMultipleInstances = instances.length > 1;
                    const isExpanded = expandedCovers.has(coverName);

                    return (
                      <div key={coverName} style={{ display: "flex", flexDirection: "column", gap: 2 }}>
                        <div style={{ display: "flex", alignItems: "center", gap: 4 }}>
                          {hasMultipleInstances && (
                            <div
                              onClick={(e) => {
                                e.stopPropagation();
                                setExpandedCovers((prev) => {
                                  const next = new Set(prev);
                                  if (next.has(coverName)) {
                                    next.delete(coverName);
                                  } else {
                                    next.add(coverName);
                                  }
                                  return next;
                                });
                              }}
                              style={{
                                fontSize: 10,
                                cursor: "pointer",
                                color: "#888",
                                minWidth: 14,
                                textAlign: "center",
                              }}
                            >
                              {isExpanded ? "▼" : "▶"}
                            </div>
                          )}
                          <div
                            onClick={() => toggleCoverTransparency(coverName)}
                            style={{
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "space-between",
                              fontSize: 12,
                              cursor: "pointer",
                              padding: "6px 8px",
                              background: level > 0 ? "#2a2a35" : "transparent",
                              borderRadius: 3,
                              transition: "background 0.15s",
                              border: `1px solid ${level > 0 ? colors[level] : "#333"}`,
                              flex: 1,
                            }}
                          >
                            <span style={{ color: level > 0 ? colors[level] : "#ccc" }}>
                              {coverName} {hasMultipleInstances && `(${instances.length})`}
                            </span>
                            <span
                              style={{
                                fontSize: 10,
                                color: colors[level],
                                fontWeight: level > 0 ? 600 : 400,
                                minWidth: 40,
                                textAlign: "right",
                              }}
                            >
                              {labels[level]}
                            </span>
                          </div>
                        </div>

                        {isExpanded && hasMultipleInstances && (
                          <div style={{ marginLeft: 20, display: "flex", flexDirection: "column", gap: 2 }}>
                            {instances.map((instanceName) => {
                              const instLevel = coverTransparency.get(instanceName) || 0;
                              return (
                                <div
                                  key={instanceName}
                                  onClick={() => toggleCoverTransparency(instanceName)}
                                  style={{
                                    display: "flex",
                                    alignItems: "center",
                                    justifyContent: "space-between",
                                    fontSize: 11,
                                    cursor: "pointer",
                                    padding: "4px 6px",
                                    background: instLevel > 0 ? "#1a1a25" : "transparent",
                                    borderRadius: 2,
                                    border: `1px solid ${instLevel > 0 ? colors[instLevel] : "#222"}`,
                                    opacity: 0.9,
                                  }}
                                >
                                  <span style={{ color: instLevel > 0 ? colors[instLevel] : "#999" }}>
                                    {instanceName}
                                  </span>
                                  <span
                                    style={{
                                      fontSize: 9,
                                      color: colors[instLevel],
                                      fontWeight: instLevel > 0 ? 600 : 400,
                                      minWidth: 30,
                                      textAlign: "right",
                                    }}
                                  >
                                    {labels[instLevel]}
                                  </span>
                                </div>
                              );
                            })}
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              </>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default GLTFViewer;
